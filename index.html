--- FRONTEND: index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Aflatoxin HPLC — Responsive + Validation QC</title>
  <style>
    :root{--bg:#f7fafc;--card:#fff;--accent:#0b74de;--muted:#6b7280}
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter, system-ui, Arial;background:var(--bg);color:#0f172a}
    .container{max-width:1100px;margin:18px auto;padding:12px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
    h1{font-size:1.25rem;margin:0}
    .grid{display:grid;gap:12px}
    .card{background:var(--card);padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(2,6,23,0.06)}
    .row{display:flex;gap:8px;align-items:center}
    input,select,button{padding:8px;border:1px solid #e6edf3;border-radius:8px}
    button{background:var(--accent);color:#fff;border:none}
    table{width:100%;border-collapse:collapse}
    th,td{border:1px solid #e6edf3;padding:6px;text-align:center;font-size:0.9rem}

    /* responsive layout */
    @media(min-width:900px){
      .two-cols{grid-template-columns:1fr 360px}
      .three-cols{grid-template-columns:repeat(3,1fr)}
    }
    @media(max-width:899px){
      .row{flex-direction:column;align-items:stretch}
      header{flex-direction:column;align-items:flex-start}
    }

    .muted{color:var(--muted)}
    .small{font-size:.85rem}
    .danger{background:#ef4444}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Aflatoxin HPLC — Mobile-responsive + Validation QC</h1>
      <div class="small muted">Four toxins: B1, B2, G1, G2 — single calibration size enforced</div>
    </header>

    <div class="grid two-cols">
      <div class="card">
        <h2 class="small">Standards — same count for each toxin</h2>

        <div class="row">
          <label class="small muted">Number of standard points</label>
          <select id="stdCount"></select>
          <button id="applyStdCount">Apply</button>
        </div>

        <div id="standardsContainer" style="margin-top:12px"></div>

        <div style="margin-top:12px" class="muted small">For each standard point enter concentration (µg/kg), area, and retention time (min). The app will enforce the same number of points across all toxins.</div>
      </div>

      <div class="card">
        <h2 class="small">Validation QC & Linearity</h2>
        <div id="linearityTable"></div>
        <div id="lodloq" style="margin-top:10px"></div>
        <div style="margin-top:12px" class="muted small">LOD/LOQ are calculated per toxin using residual standard deviation (sy) and slope: LOD = 3.3·sy/slope, LOQ = 10·sy/slope.</div>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <h2 class="small">Samples & Peak Matching</h2>
        <div class="row">
          <label class="small muted">RT tolerance (min)</label>
          <input id="rtTol" style="width:88px" />
          <label class="small muted">Dilution</label>
          <input id="dilution" style="width:88px" />
          <label class="small muted">Sample weight (g)</label>
          <input id="sampleWeight" style="width:88px" />
          <button id="addSample">Add sample</button>
        </div>

        <div id="samplesContainer" style="margin-top:12px"></div>
      </div>
    </div>

    <div class="grid three-cols" style="margin-top:12px">
      <div class="card">
        <h3 class="small">Overlay Calibration Chart</h3>
        <canvas id="overlayChart" height="200" style="width:100%;max-width:100%"></canvas>
      </div>
      <div class="card">
        <h3 class="small">Results</h3>
        <div id="resultsTable"></div>
      </div>
      <div class="card">
        <h3 class="small">Export / Backend</h3>
        <div class="row">
          <button id="openReport">Open printable report</button>
          <button id="saveReport">Save to server</button>
        </div>
        <div id="serverMsg" class="small muted" style="margin-top:8px"></div>
      </div>
    </div>

    <footer style="margin-top:12px" class="muted small">Note: Validate results vs your SOP. This tool provides calculations to assist — not replace — method validation.</footer>
  </div>

  <script>
  // --- State ---
  const TOXINS = ["B1","B2","G1","G2"];
  let stdCount = 3; // enforced across toxins
  let standards = {};
  let samples = [];
  let rtTolerance = 0.2;
  let dilution = 1;
  let sampleWeight = 5;

  // initialize
  function initState(){
    for(const t of TOXINS){
      standards[t] = [];
      for(let i=0;i<stdCount;i++) standards[t].push({ id: i+1, conc: (i===0?0:(i===1?1:5)), area:'', rt:'' });
    }
    samples = [{ id:1, name:'Sample A', peaks:[] }];
  }

  initState();

  // DOM refs
  const stdCountSelect = document.getElementById('stdCount');
  const applyStdBtn = document.getElementById('applyStdCount');
  const standardsContainer = document.getElementById('standardsContainer');
  const samplesContainer = document.getElementById('samplesContainer');
  const overlayCanvas = document.getElementById('overlayChart');
  const resultsTableDiv = document.getElementById('resultsTable');
  const linearityDiv = document.getElementById('linearityTable');
  const lodloqDiv = document.getElementById('lodloq');
  const rtTolInput = document.getElementById('rtTol');
  const dilutionInput = document.getElementById('dilution');
  const sampleWeightInput = document.getElementById('sampleWeight');
  const addSampleBtn = document.getElementById('addSample');
  const openReportBtn = document.getElementById('openReport');
  const saveReportBtn = document.getElementById('saveReport');
  const serverMsg = document.getElementById('serverMsg');

  // populate stdCount selector
  for(let i=2;i<=8;i++){ const opt = document.createElement('option'); opt.value = i; opt.textContent=i; stdCountSelect.appendChild(opt);} stdCountSelect.value=stdCount;

  applyStdBtn.addEventListener('click',()=>{
    const n = parseInt(stdCountSelect.value)||3; setStandardCount(n); render();
  });

  rtTolInput.value = rtTolerance; rtTolInput.addEventListener('change', ()=>{ rtTolerance = parseFloat(rtTolInput.value)||0.2; renderResults(); });
  dilutionInput.value = dilution; dilutionInput.addEventListener('change', ()=>{ dilution = parseFloat(dilutionInput.value)||1; renderResults(); });
  sampleWeightInput.value = sampleWeight; sampleWeightInput.addEventListener('change', ()=>{ sampleWeight = parseFloat(sampleWeightInput.value)||1; renderResults(); });

  addSampleBtn.addEventListener('click', ()=>{ samples.push({ id: Date.now(), name:'New sample', peaks:[] }); render(); });
  openReportBtn.addEventListener('click', ()=>{ openPrintableReport(); });
  saveReportBtn.addEventListener('click', ()=>{ saveReportToServer(); });

  // Helper math
  function linearRegression(points){
    if(!points || points.length<2) return null;
    const n = points.length;
    const sumX = points.reduce((a,b)=>a+b.x,0);
    const sumY = points.reduce((a,b)=>a+b.y,0);
    const sumXY = points.reduce((a,b)=>a+b.x*b.y,0);
    const sumX2 = points.reduce((a,b)=>a+b.x*b.x,0);
    const denom = n*sumX2 - sumX*sumX; if(Math.abs(denom)<1e-12) return null;
    const slope = (n*sumXY - sumX*sumY)/denom;
    const intercept = (sumY - slope*sumX)/n;
    // residuals & sy (standard error of estimate)
    const ssRes = points.reduce((a,b)=>a+Math.pow(b.y - (slope*b.x + intercept),2),0);
    const sy = Math.sqrt(ssRes/(n-2));
    // compute r2
    const meanY = sumY/n; const ssTot = points.reduce((a,b)=>a+Math.pow(b.y-meanY,2),0);
    const r2 = ssTot===0?1:1 - ssRes/ssTot;
    return { slope, intercept, sy, r2 };
  }

  function computeCalibrations(){
    const out = {};
    for(const t of TOXINS){
      const pts = standards[t].map(s=>({ x: Number(s.area)||0, y: Number(s.conc)||0 })).filter(p=>p.x>0);
      out[t] = linearRegression(pts);
    }
    return out;
  }

  function predict(toxin, area, cal){ if(!cal || !cal[toxin]) return 0; const x = Number(area)||0; return cal[toxin].slope * x + cal[toxin].intercept; }

  function matchPeaks(peaks){
    const refRT = {};
    for(const t of TOXINS){
      const rts = standards[t].map(s=>Number(s.rt)||NaN).filter(v=>!isNaN(v));
      if(rts.length) refRT[t] = rts.reduce((a,b)=>a+b,0)/rts.length;
    }
    return peaks.map(p=>{
      const rt = Number(p.rt); if(isNaN(rt)) return {...p, matched:null};
      let best=null, bestDiff=Infinity;
      for(const t in refRT){ const d = Math.abs(refRT[t]-rt); if(d<=rtTolerance && d<bestDiff){ best=t; bestDiff=d; }}
      return {...p, matched:best, rtDiff: bestDiff===Infinity? null: bestDiff };
    });
  }

  function computeSampleResults(sample, cal){
    const matched = matchPeaks(sample.peaks);
    const per = {}; TOXINS.forEach(t=>per[t]=0);
    for(const p of matched){ if(p.matched){ per[p.matched] += predict(p.matched, p.area, cal); }}
    const total = TOXINS.reduce((a,t)=>a+per[t],0);
    const corrected = (total * dilution) / sampleWeight;
    return { per, total, corrected, matched };
  }

  // QC calculations: recovery %, linearity table, LOD/LOQ
  function computeQC(){
    const cal = computeCalibrations();
    const linearity = {};
    const lodloq = {};
    for(const t of TOXINS){
      const pts = standards[t].map(s=>({ x: Number(s.area)||0, y: Number(s.conc)||0 })).filter(p=>p.x>0);
      const c = cal[t];
      linearity[t] = pts.map(p=>{
        const pred = c ? c.slope*p.x + c.intercept : 0;
        return { area:p.x, actual:p.y, predicted:pred, residual: p.y - pred };
      });
      if(c && c.slope && c.sy){
        const LOD = 3.3 * c.sy / Math.abs(c.slope);
        const LOQ = 10 * c.sy / Math.abs(c.slope);
        lodloq[t] = { LOD, LOQ, slope:c.slope, intercept:c.intercept, r2:c.r2 };
      } else {
        lodloq[t] = null;
      }
    }
    return { linearity, lodloq };
  }

  // --- Render functions ---
  function setStandardCount(n){
    stdCount = n;
    for(const t of TOXINS){
      const arr = standards[t];
      while(arr.length < n){ arr.push({ id: Date.now()+Math.random(), conc:'', area:'', rt:'' }); }
      while(arr.length > n){ arr.pop(); }
    }
  }

  function renderStandards(){
    standardsContainer.innerHTML = '';
    for(const t of TOXINS){
      const card = document.createElement('div'); card.className='card';
      const h = document.createElement('h3'); h.textContent = 'Aflatoxin '+t; h.className='small'; card.appendChild(h);
      const grid = document.createElement('div'); grid.style.display='grid'; grid.style.gap='6px';
      standards[t].forEach((pt, idx)=>{
        const row = document.createElement('div'); row.className='row';
        const conc = document.createElement('input'); conc.value = pt.conc; conc.placeholder='conc'; conc.onchange = e=>{ pt.conc = e.target.value; renderResults(); };
        const area = document.createElement('input'); area.value = pt.area; area.placeholder='area'; area.onchange = e=>{ pt.area = e.target.value; renderResults(); };
        const rt = document.createElement('input'); rt.value = pt.rt; rt.placeholder='RT (min)'; rt.onchange = e=>{ pt.rt = e.target.value; renderResults(); };
        const del = document.createElement('button'); del.className='btn danger'; del.textContent='×'; del.onclick = ()=>{ standards[t].splice(idx,1); setStandardCount(stdCount); render(); };
        row.appendChild(conc); row.appendChild(area); row.appendChild(rt); row.appendChild(del);
        grid.appendChild(row);
      });
      const add = document.createElement('button'); add.className='btn'; add.textContent='Add point'; add.onclick=()=>{ standards[t].push({ id:Date.now(), conc:'', area:'', rt:'' }); setStandardCount(stdCount); render(); };
      card.appendChild(grid); card.appendChild(add);
      standardsContainer.appendChild(card);
    }
  }

  function renderSamples(){
    samplesContainer.innerHTML = '';
    samples.forEach(s=>{
      const card = document.createElement('div'); card.className='card';
      const name = document.createElement('input'); name.value = s.name; name.onchange = e=>{ s.name = e.target.value; renderResults(); };
      const peaksDiv = document.createElement('div'); peaksDiv.style.marginTop='8px';
      s.peaks.forEach((p, idx)=>{
        const row = document.createElement('div'); row.className='row';
        const rt = document.createElement('input'); rt.placeholder='RT'; rt.value = p.rt; rt.onchange = e=>{ p.rt = e.target.value; renderResults(); };
        const area = document.createElement('input'); area.placeholder='Area'; area.value = p.area; area.onchange = e=>{ p.area = e.target.value; renderResults(); };
        const del = document.createElement('button'); del.className='btn danger'; del.textContent='×'; del.onclick=()=>{ s.peaks.splice(idx,1); render(); };
        row.appendChild(rt); row.appendChild(area); row.appendChild(del);
        peaksDiv.appendChild(row);
      });
      const addPeak = document.createElement('button'); addPeak.className='btn'; addPeak.textContent='Add peak'; addPeak.onclick=()=>{ s.peaks.push({ id:Date.now(), rt:'', area:'' }); render(); };
      card.appendChild(name); card.appendChild(peaksDiv); card.appendChild(addPeak);
      samplesContainer.appendChild(card);
    });
  }

  // simple chart (overlay) using Canvas 2D (no external libs)
  function renderOverlayChart(){
    const cal = computeCalibrations();
    // gather unique area values from standards
    const areas = new Set();
    for(const t of TOXINS){ standards[t].forEach(s=>{ const a = Number(s.area); if(a>0) areas.add(a); }); }
    const xs = Array.from(areas).sort((a,b)=>a-b);
    const rows = xs.map(a=>{ const row = { area:a }; for(const t of TOXINS){ const c = cal[t]; row[t] = c? c.slope*a + c.intercept : null; } return row; });

    const ctx = overlayCanvas.getContext('2d'); overlayCanvas.width = overlayCanvas.clientWidth; overlayCanvas.height = 240; ctx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
    if(rows.length===0) { ctx.fillStyle='#666'; ctx.fillText('No calibration points',10,20); return; }
    // compute bounds
    const minX = Math.min(...rows.map(r=>r.area));
    const maxX = Math.max(...rows.map(r=>r.area));
    const vals = rows.flatMap(r=>TOXINS.map(t=>r[t]).filter(v=>v!=null));
    const minY = Math.min(...vals); const maxY = Math.max(...vals);
    const pad = 20;
    function tx(x){ return pad + (overlayCanvas.width-2*pad) * ((x-minX)/(maxX-minX||1)); }
    function ty(y){ return overlayCanvas.height - pad - (overlayCanvas.height-2*pad) * ((y-minY)/(maxY-minY||1)); }
    const colors = ['#003f5c','#58508d','#bc5090','#ff6361'];
    // axes
    ctx.strokeStyle='#ddd'; ctx.beginPath(); ctx.moveTo(pad,pad); ctx.lineTo(pad,overlayCanvas.height-pad); ctx.lineTo(overlayCanvas.width-pad,overlayCanvas.height-pad); ctx.stroke();
    // lines
    TOXINS.forEach((t,idx)=>{
      ctx.beginPath(); ctx.strokeStyle = colors[idx]; let started=false;
      rows.forEach(r=>{ if(r[t]!=null){ const x = tx(r.area); const y = ty(r[t]); if(!started){ ctx.moveTo(x,y); started=true; } else ctx.lineTo(x,y); }});
      ctx.stroke();
    });
  }

  function renderResults(){
    const cal = computeCalibrations();
    // compute results table
    let html = '<table><thead><tr><th>Sample</th>' + TOXINS.map(t=>`<th>${t}</th>`).join('') + '<th>Total</th><th>Corrected</th></tr></thead><tbody>';
    for(const s of samples){
      const r = computeSampleResults(s, cal);
      html += '<tr><td>'+escapeHtml(s.name)+'</td>' + TOXINS.map(t=>`<td>${r.per[t].toFixed(3)}</td>`).join('') + `<td>${r.total.toFixed(3)}</td><td>${r.corrected.toFixed(3)}</td></tr>`;
    }
    html += '</tbody></table>';
    resultsTableDiv.innerHTML = html;

    // linearity & LOD/LOQ
    const qc = computeQC();
    // linearity table
    let linHtml = '';
    for(const t of TOXINS){
      linHtml += `<h4 class="small">${t} (R²=${qc.lodloq[t]? qc.lodloq[t].r2.toFixed(4): '—'})</h4>`;
      linHtml += '<table><thead><tr><th>Area</th><th>Actual</th><th>Predicted</th><th>Residual</th></tr></thead><tbody>';
      for(const r of qc.linearity[t]) linHtml += `<tr><td>${r.area}</td><td>${r.actual}</td><td>${r.predicted.toFixed(4)}</td><td>${r.residual.toFixed(4)}</td></tr>`;
      linHtml += '</tbody></table>';
    }
    linearityDiv.innerHTML = linHtml;

    // LOD/LOQ
    let loHtml = '<table><thead><tr><th>Toxin</th><th>Slope</th><th>Sy</th><th>LOD</th><th>LOQ</th></tr></thead><tbody>';
    for(const t of TOXINS){
      const info = qc.lodloq[t];
      if(info) loHtml += `<tr><td>${t}</td><td>${info.slope.toFixed(6)}</td><td>${(computeCalibrations()[t].sy||0).toFixed(6)}</td><td>${info.LOD.toFixed(6)}</td><td>${info.LOQ.toFixed(6)}</td></tr>`;
      else loHtml += `<tr><td>${t}</td><td colspan="4">Insufficient data</td></tr>`;
    }
    loHtml += '</tbody></table>';
    lodloqDiv.innerHTML = loHtml;

    renderOverlayChart();
  }

  function render(){
    renderStandards(); renderSamples(); renderResults();
  }

  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // Printable report generator
  function openPrintableReport(){
    const cal = computeCalibrations();
    const qc = computeQC();
    const rows = samples.map(s=>{
      const r = computeSampleResults(s,cal);
      return `<tr><td>${escapeHtml(s.name)}</td>${TOXINS.map(t=>`<td>${r.per[t].toFixed(3)}</td>`).join('')}<td>${r.total.toFixed(3)}</td><td>${r.corrected.toFixed(3)}</td></tr>`;
    }).join('');

    const html = `<!doctype html><html><head><meta charset="utf-8"><title>Report</title><style>table{border-collapse:collapse;width:100%}td,th{border:1px solid #333;padding:6px}</style></head><body><h1>Aflatoxin HPLC Report</h1><p>Dilution: ${dilution} — Sample weight: ${sampleWeight} g — RT tol: ${rtTolerance} min</p><h2>Results</h2><table><thead><tr><th>Sample</th>${TOXINS.map(t=>`<th>${t}</th>`).join('')}<th>Total</th><th>Corrected</th></tr></thead><tbody>${rows}</tbody></table><h2>Linearity</h2>${Object.keys(qc.linearity).map(t=>`<h3>${t}</h3><table><thead><tr><th>Area</th><th>Actual</th><th>Pred</th><th>Res</th></tr></thead><tbody>${qc.linearity[t].map(r=>`<tr><td>${r.area}</td><td>${r.actual}</td><td>${r.predicted.toFixed(4)}</td><td>${r.residual.toFixed(4)}</td></tr>`).join('')}</tbody></table>`).join('')}<h2>LOD / LOQ</h2><pre>${JSON.stringify(qc.lodloq,null,2)}</pre></body></html>`;

    const w = window.open('','_blank'); w.document.write(html); w.document.close();
  }

  // --- Backend integration (Express + SQLite) ---
  // Save report to server; server should expose POST /api/reports accepting JSON
  async function saveReportToServer(){
    const cal = computeCalibrations();
    const report = {
      timestamp: new Date().toISOString(),
      dilution, sampleWeight, rtTolerance,
      standards, samples, calibrations: cal
    };
    try{
      const res = await fetch('/api/reports', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(report) });
      if(res.ok){ const data = await res.json(); serverMsg.textContent = 'Saved (id: '+data.id+')'; } else { serverMsg.textContent = 'Save failed: '+res.status; }
    }catch(e){ serverMsg.textContent = 'Server unreachable'; }
  }

  // helpers
  function setStandardCountFromUI(){ const n = parseInt(stdCountSelect.value)||3; setStandardCount(n); render(); }

  // initial values
  stdCountSelect.addEventListener('change', setStandardCountFromUI);
  // start
  render();
  </script>
</body>
</html>


--- BACKEND: server.js ---
// Simple Express + SQLite backend to receive reports and store them.
// Run: npm install express sqlite3 body-parser cors
// Start: node server.js

const express = require('express');
const sqlite3 = require('sqlite3').verbose();
const path = require('path');
const fs = require('fs');
const bodyParser = require('body-parser');
const cors = require('cors');

const DB_FILE = path.join(__dirname,'aflatoxin_reports.db');
const db = new sqlite3.Database(DB_FILE);

// initialize DB
db.serialize(()=>{
  db.run(`CREATE TABLE IF NOT EXISTS reports (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TEXT,
    payload TEXT
  )`);
});

const app = express();
app.use(cors());
app.use(bodyParser.json({ limit:'5mb' }));

// serve static frontend if present
app.use(express.static(path.join(__dirname,'public')));

app.post('/api/reports', (req,res)=>{
  const payload = JSON.stringify(req.body);
  db.run(`INSERT INTO reports (timestamp,payload) VALUES (?,?)`, [new Date().toISOString(), payload], function(err){
    if(err) return res.status(500).json({ error: err.message });
    res.json({ id: this.lastID });
  });
});

app.get('/api/reports', (req,res)=>{
  db.all(`SELECT id, timestamp FROM reports ORDER BY id DESC`, [], (err,rows)=>{
    if(err) return res.status(500).json({ error: err.message });
    res.json(rows);
  });
});

app.get('/api/reports/:id', (req,res)=>{
  db.get(`SELECT id, timestamp, payload FROM reports WHERE id = ?`, [req.params.id], (err,row)=>{
    if(err) return res.status(500).json({ error: err.message });
    if(!row) return res.status(404).json({ error:'not found' });
    row.payload = JSON.parse(row.payload);
    res.json(row);
  });
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, ()=> console.log('Server listening on', PORT));

--- BACKEND: package.json ---
{
  "name": "aflatoxin-backend",
  "version": "0.1.0",
  "main": "server.js",
  "scripts": {
    "start": "node server.js"
  },
  "dependencies": {
    "body-parser": "^1.20.2",
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "sqlite3": "^5.1.6"
  }
}

--- README / RUN INSTRUCTIONS ---
1) Frontend: save the FRONTEND section as `index.html` inside a `public/` folder (or open it directly in a browser). The UI is responsive and will adapt to mobile.

2) Backend: place `server.js` and `package.json` in a folder, run `npm install`, then `npm start`. The server serves static files from `public/` if you put the frontend there.

3) Save reports: use the "Save to server" button in the UI. The server stores reports in `aflatoxin_reports.db` (SQLite).

--- NOTES & ASSUMPTIONS ---
- The frontend enforces an identical standard point count across all toxins (user sets the count at top-left). You can still edit concentrations/areas/RT per toxin.
- LOD/LOQ computed per toxin using regression residual standard deviation (sy) and slope. This follows the standard formula LOD = 3.3·sy/slope and LOQ = 10·sy/slope. It requires at least two non-zero-area points to compute.
- Recovery %: you can use the samples area/peak-based workflow. If you want a dedicated spike/recovery module (automatically compute recovery vs known spiked concentration), I can add a simple UI to input spike amounts and compute % recovery per sample/toxin.

If you'd like, I can now:
- Package the whole project into a ZIP and provide it for download. ✅
- Add a dedicated Recovery % tool (spike management + auto-report). ✅
- Harden the backend (validation, auth) and add an endpoint to export CSV/XLSX. ✅

Tell me which of the next steps you want and I'll do it right away.
