import React, { useState, useMemo, useRef } from "react";
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  Tooltip,
  CartesianGrid,
  ResponsiveContainer,
  Legend
} from "recharts";

const TOXINS = ["B1", "B2", "G1", "G2"];

export default function AflatoxinCalculatorApp() {
  // Per-toxin standards: { B1: [{id, conc, area, rt}], B2: [...], ... }
  const [standards, setStandards] = useState(() => {
    const base = {};
    TOXINS.forEach((t) => {
      base[t] = [
        { id: Date.now() + 1 + Math.random(), conc: 0, area: "", rt: "" },
        { id: Date.now() + 2 + Math.random(), conc: 1, area: "", rt: "" },
        { id: Date.now() + 3 + Math.random(), conc: 5, area: "", rt: "" }
      ];
    });
    return base;
  });

  // Samples: each sample can have measured peaks (area + rt) per toxin or raw peaks list
  const [samples, setSamples] = useState([
    { id: 1, name: "Sample A", peaks: [/* {rt, area} */] }
  ]);

  const [dilution, setDilution] = useState(1);
  const [sampleWeight, setSampleWeight] = useState(5); // g
  const [rtTolerance, setRtTolerance] = useState(0.2); // minutes tolerance for matching

  // refs for chart containers so we can serialize SVG for printable report
  const chartRefs = useRef({});

  function updateStandard(toxin, id, field, value) {
    setStandards((s) => ({
      ...s,
      [toxin]: s[toxin].map((r) => (r.id === id ? { ...r, [field]: value } : r))
    }));
  }

  function addStandardPoint(toxin) {
    setStandards((s) => ({
      ...s,
      [toxin]: [...s[toxin], { id: Date.now() + Math.random(), conc: "", area: "", rt: "" }]
    }));
  }

  function removeStandardPoint(toxin, id) {
    setStandards((s) => ({ ...s, [toxin]: s[toxin].filter((r) => r.id !== id) }));
  }

  function addSample() {
    setSamples((s) => [...s, { id: Date.now(), name: "New Sample", peaks: [] }]);
  }

  function addPeakToSample(sampleId) {
    setSamples((s) => s.map((sm) => (sm.id === sampleId ? { ...sm, peaks: [...sm.peaks, { id: Date.now(), rt: "", area: "" }] } : sm)));
  }

  function updateSamplePeak(sampleId, peakId, field, value) {
    setSamples((s) => s.map((sm) => {
      if (sm.id !== sampleId) return sm;
      return { ...sm, peaks: sm.peaks.map(p => p.id === peakId ? { ...p, [field]: value } : p) };
    }));
  }

  function removeSamplePeak(sampleId, peakId) {
    setSamples((s) => s.map((sm) => sm.id === sampleId ? { ...sm, peaks: sm.peaks.filter(p => p.id !== peakId) } : sm));
  }

  // least-squares linear regression for points array [{x, y}]
  function linearRegression(points) {
    if (!points || points.length < 2) return null;
    const n = points.length;
    const sumX = points.reduce((a, b) => a + b.x, 0);
    const sumY = points.reduce((a, b) => a + b.y, 0);
    const sumXY = points.reduce((a, b) => a + b.x * b.y, 0);
    const sumX2 = points.reduce((a, b) => a + b.x * b.x, 0);
    const denom = n * sumX2 - sumX * sumX;
    if (Math.abs(denom) < 1e-12) return null;
    const slope = (n * sumXY - sumX * sumY) / denom;
    const intercept = (sumY - slope * sumX) / n;
    const meanY = sumY / n;
    const ssTot = points.reduce((a, b) => a + Math.pow(b.y - meanY, 2), 0);
    const ssRes = points.reduce((a, b) => a + Math.pow(b.y - (slope * b.x + intercept), 2), 0);
    const r2 = ssTot === 0 ? 1 : 1 - ssRes / ssTot;
    return { slope, intercept, r2 };
  }

  // compute calibrations for each toxin
  const calibrations = useMemo(() => {
    const result = {};
    TOXINS.forEach((t) => {
      const pts = standards[t]
        .map((p) => ({ x: parseFloat(p.area) || 0, y: parseFloat(p.conc) || 0 }))
        .filter(p => p.x > 0);
      result[t] = linearRegression(pts);
    });
    return result;
  }, [standards]);

  // predict concentration for a toxin given area
  function predictConcentrationFor(toxin, area) {
    const cal = calibrations[toxin];
    if (!cal) return 0;
    const x = parseFloat(area) || 0;
    return cal.slope * x + cal.intercept;
  }

  // match peaks to toxins by retention time (closest within tolerance)
  function matchPeaksToToxins(peaks) {
    // build reference RTs from standards: mean RT per toxin
    const refRT = {};
    TOXINS.forEach((t) => {
      const rts = standards[t]
        .map(s => parseFloat(s.rt) || NaN)
        .filter(v => !isNaN(v));
      if (rts.length) refRT[t] = rts.reduce((a,b)=>a+b,0)/rts.length;
    });

    return peaks.map(p => {
      const rt = parseFloat(p.rt);
      if (isNaN(rt)) return { ...p, matched: null, reason: 'no RT' };
      let best = null;
      let bestDiff = Infinity;
      Object.entries(refRT).forEach(([t, r]) => {
        const diff = Math.abs(r - rt);
        if (diff <= Number(rtTolerance) && diff < bestDiff) {
          best = t; bestDiff = diff;
        }
      });
      return { ...p, matched: best, rtDiff: bestDiff === Infinity ? null : bestDiff };
    });
  }

  function computeSampleResults(sample) {
    // map peaks to toxins; for each toxin sum predicted concentration from matched peak(s) or use direct per-toxin area if user entered that way
    const matchedPeaks = matchPeaksToToxins(sample.peaks);
    const perToxin = {};
    TOXINS.forEach(t => perToxin[t] = 0);
    matchedPeaks.forEach(p => {
      if (!p.matched) return;
      const conc = predictConcentrationFor(p.matched, p.area);
      perToxin[p.matched] += conc;
    });
    const total = TOXINS.reduce((a,t) => a + perToxin[t], 0);
    const corrected = (total * Number(dilution || 1)) / Number(sampleWeight || 1);
    return { perToxin, total, corrected, matchedPeaks };
  }

  // export printable report that includes small serialized SVG charts
  function exportReport() {
    // gather serialized SVGs
    const svgSnippets = {};
    TOXINS.forEach(t => {
      const el = chartRefs.current[`chart_${t}`];
      svgSnippets[t] = el ? el.innerHTML : "";
    });
    // overlay chart
    const overlayEl = chartRefs.current[`chart_overlay`];
    const overlaySvg = overlayEl ? overlayEl.innerHTML : "";

    const rows = samples.map(s => {
      const r = computeSampleResults(s);
      return `<tr><td>${s.name}</td>${TOXINS.map(t=>`<td>${r.perToxin[t].toFixed(3)}</td>`).join('')}<td>${r.total.toFixed(3)}</td><td>${r.corrected.toFixed(3)}</td></tr>`;
    }).join('
');

    const html = `
      <html><head><meta charset="utf-8"><title>Aflatoxin Report</title>
      <style>body{font-family:Arial,Helvetica,sans-serif;padding:20px}table{border-collapse:collapse;width:100%}td,th{border:1px solid #333;padding:6px;text-align:center}h1,h2{margin:8px 0}</style></head><body>
      <h1>Aflatoxin HPLC Report</h1>
      <p>Dilution: ${dilution} — Sample weight: ${sampleWeight} g — RT tolerance: ${rtTolerance} min</p>
      <h2>Charts — per-toxin</h2>
      ${TOXINS.map(t=>`<h3>${t}</h3><div>${svgSnippets[t]||'<em>No chart</em>'}</div>`).join('')}
      <h2>Overlay calibration</h2>
      <div>${overlaySvg||'<em>No overlay chart</em>'}</div>
      <h2>Results</h2>
      <table><thead><tr><th>Sample</th>${TOXINS.map(t=>`<th>${t}</th>`).join('')}<th>Total</th><th>Corrected</th></tr></thead><tbody>${rows}</tbody></table>
      </body></html>
    `;

    const w = window.open("", "_blank");
    w.document.write(html);
    w.document.close();
  }

  // build chart data per toxin from standards points
  function chartDataFor(toxin) {
    return (standards[toxin] || [])
      .map((p, idx) => ({ name: `Std ${idx + 1}`, area: parseFloat(p.area) || 0, conc: parseFloat(p.conc) || 0 }))
      .filter(p => p.area > 0);
  }

  // overlay chart data: combine unique area values and plot predicted conc for each toxin
  function overlayChartData() {
    const areas = new Set();
    TOXINS.forEach(t => chartDataFor(t).forEach(p => areas.add(p.area)));
    const sorted = Array.from(areas).sort((a,b)=>a-b);
    return sorted.map(a => {
      const row = { area: a };
      TOXINS.forEach(t => {
        const cal = calibrations[t];
        row[t] = cal ? (cal.slope * a + cal.intercept) : null;
      });
      return row;
    });
  }

  return (
    <div className="min-h-screen bg-slate-50 p-6">
      <div className="max-w-7xl mx-auto">
        <h1 className="text-3xl font-bold mb-4">Aflatoxin HPLC — 4-channel Calibration + Peak Matching</h1>

        <section className="bg-white p-4 rounded-2xl shadow mb-6">
          <h2 className="text-xl font-semibold mb-2">Per-toxin Standards (enter concentration, area, retention time)</h2>
          <div className="grid grid-cols-4 gap-4">
            {TOXINS.map((t) => (
              <div key={t} className="p-3 border rounded">
                <h3 className="font-semibold">Aflatoxin {t}</h3>
                <div className="space-y-2">
                  {(standards[t] || []).map(pt => (
                    <div key={pt.id} className="grid grid-cols-3 gap-2 items-center">
                      <input className="input" value={pt.conc} onChange={(e)=>updateStandard(t, pt.id, 'conc', e.target.value)} placeholder="conc (µg/kg)" />
                      <input className="input" value={pt.area} onChange={(e)=>updateStandard(t, pt.id, 'area', e.target.value)} placeholder="area" />
                      <div className="flex gap-2">
                        <input className="input" value={pt.rt} onChange={(e)=>updateStandard(t, pt.id, 'rt', e.target.value)} placeholder="RT (min)" />
                        <button className="btn" onClick={()=>removeStandardPoint(t, pt.id)}>×</button>
                      </div>
                    </div>
                  ))}
                </div>
                <div className="mt-2">
                  <button className="btn" onClick={()=>addStandardPoint(t)}>Add standard point</button>
                </div>
                <div className="mt-2 text-sm">
                  {calibrations[t] ? (
                    <div>
                      <div>Slope: {calibrations[t].slope.toFixed(6)}</div>
                      <div>Intercept: {calibrations[t].intercept.toFixed(6)}</div>
                      <div>R²: {calibrations[t].r2.toFixed(4)}</div>
                    </div>
                  ) : <div className="text-amber-600">Provide ≥2 standards with non-zero area</div>}
                </div>
                <div style={{height:160}} ref={(el)=>{ if(el) chartRefs.current[`chart_${t}`]=el }}>
                  {calibrations[t] ? (
                    <ResponsiveContainer width="100%" height={160}>
                      <LineChart data={chartDataFor(t)}>
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis dataKey="area" />
                        <YAxis />
                        <Tooltip />
                        <Line type="monotone" dataKey="conc" stroke="#0b74de" />
                      </LineChart>
                    </ResponsiveContainer>
                  ) : <div className="text-sm text-slate-500">No chart</div>}
                </div>
              </div>
            ))}
          </div>
        </section>

        <section className="bg-white p-4 rounded-2xl shadow mb-6">
          <h2 className="text-xl font-semibold mb-2">Overlay Calibration Chart</h2>
          <div style={{height:320}} ref={(el)=>{ if(el) chartRefs.current[`chart_overlay`]=el }}>
            <ResponsiveContainer width="100%" height={320}>
              <LineChart data={overlayChartData()}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="area" />
                <YAxis />
                <Tooltip />
                <Legend />
                {TOXINS.map((t, i) => (
                  <Line key={t} type="monotone" dataKey={t} stroke={["#003f5c","#58508d","#bc5090","#ff6361"][i]} dot={false} />
                ))}
              </LineChart>
            </ResponsiveContainer>
          </div>
        </section>

        <section className="bg-white p-4 rounded-2xl shadow mb-6">
          <h2 className="text-xl font-semibold mb-2">Samples — enter detected peaks (RT + area)</h2>
          <div className="space-y-3">
            {samples.map(s => (
              <div key={s.id} className="p-3 border rounded">
                <div className="flex items-center justify-between mb-2">
                  <input className="input w-64" value={s.name} onChange={(e)=>setSamples(prev=>prev.map(x=> x.id===s.id?{...x,name:e.target.value}:x))} />
                  <div>
                    <button className="btn" onClick={()=>addPeakToSample(s.id)}>Add peak</button>
                  </div>
                </div>
                <div className="grid gap-2">
                  {s.peaks.map(p => {
                    const matchedInfo = matchPeaksToToxins([p])[0];
                    return (
                      <div key={p.id} className="grid grid-cols-6 gap-2 items-center">
                        <input className="input" value={p.rt} onChange={(e)=>updateSamplePeak(s.id, p.id, 'rt', e.target.value)} placeholder="RT (min)" />
                        <input className="input" value={p.area} onChange={(e)=>updateSamplePeak(s.id, p.id, 'area', e.target.value)} placeholder="Area" />
                        <div className="text-sm">Matched: {matchedInfo.matched || '-'} {matchedInfo.rtDiff!=null? `(Δ ${matchedInfo.rtDiff.toFixed(3)} min)` : ''}</div>
                        <div className="text-sm">Pred conc: {matchedInfo.matched ? predictConcentrationFor(matchedInfo.matched, p.area).toFixed(3) : '-'}</div>
                        <button className="btn" onClick={()=>removeSamplePeak(s.id, p.id)}>Remove</button>
                      </div>
                    );
                  })}
                </div>
                <div className="mt-2 text-sm">
                  <strong>Results:</strong>
                  {(() => {
                    const r = computeSampleResults(s);
                    return (
                      <div className="grid grid-cols-6 gap-2 mt-1 text-xs">
                        {TOXINS.map(t => <div key={t}>{t}: {r.perToxin[t].toFixed(3)}</div>)}
                        <div>Total: {r.total.toFixed(3)}</div>
                        <div>Corrected: {r.corrected.toFixed(3)}</div>
                      </div>
                    );
                  })()}
              </div>
            ))}
            <div>
              <button className="btn" onClick={addSample}>Add sample</button>
            </div>
          </div>
        </section>

        <section className="bg-white p-4 rounded-2xl shadow mb-6">
          <h2 className="text-xl font-semibold mb-2">Global settings & Export</h2>
          <div className="flex gap-4 items-center">
            <div>
              <label className="block text-sm">Dilution factor</label>
              <input className="input" value={dilution} onChange={(e)=>setDilution(e.target.value)} />
            </div>
            <div>
              <label className="block text-sm">Sample weight (g)</label>
              <input className="input" value={sampleWeight} onChange={(e)=>setSampleWeight(e.target.value)} />
            </div>
            <div>
              <label className="block text-sm">RT tolerance (min)</label>
              <input className="input" value={rtTolerance} onChange={(e)=>setRtTolerance(e.target.value)} />
            </div>
            <div>
              <button className="btn" onClick={exportReport}>Open printable report (includes charts)</button>
            </div>
          </div>
        </section>

        <footer className="text-sm text-slate-600 mt-6">This tool creates independent calibrations for B1/B2/G1/G2, matches peaks by retention time (mean RT of standards) and exports a printable report with embedded charts. Validate against your lab's SOP before reporting.</footer>
      </div>
    </div>
  );
}
